# MR-logical-mechanism

## Краткое объяснение сути проекта
Данный проект представляет собой простейшую реализацию имитации (M,R) системы Роберта Розена в качестве логического механизма с любым целым положительным числом логических блоков, которые реализуют внутри себя те или иные логические операции в бесконечнозначной (в общем случае) логике, основанной на моей аксиоматике (вы можете легко переписать мои формулы логических операций на свои). Также по мере развития этого проекта прежполгается использование такого рода логических механизмов в качестве нейронов/элементов/функций аквтивации нейронов в гипотетической нейронной сети (задача создания такой сети тривиальна, а вот как обучать её мне пока неясно, так как нет возможности брать производную от функции активации, о чём будет сказано далее).

## Что такое логический механизм на основе (M,R) системы?
Если кратко, то (M,R) система Роберта Розена - это математическое воплощение идеи Николая Рашевского о представлении модели живой клетки, как минимальной модели всего живого. Считается, что (M,R) системы Р. Розена невычислимы в рамках машины Тьюринга, однако ничто не запрещает нам пробовать имитировать некоторые их аспекты, такие, как, например, замкнутость по действующей причине. Именно такой имтиацией и является предложенных логический механизм.

Логический механизм, имитирующий (M,R) систему, моделирующую жизнь (да, посмодернизм в действии) в одном из своих вариантов кратко описывается следующими утверждениями:
1. Механизм состоит из трёх и более последовательно соединённых функциональных блоков.
2. Данные, поданные на вход первого блока, меняясь проходят через все блоки механизма.
3. На основе полученных выходных значений в результате работы каждого блока механизм проводит коррекцию обрабатывающих функций в блоках (обычно по формуле обратного закольцованного сдвига, то есть: 1 -> 3, 3 -> 2, 2 ->1, где -> идёт от меняющего к меняемому).
4. Выход последнего блока подаётся на вход первого блока, и процесс с прогоном данных через блоки и их коррекцией продолжается до тех пор, пока состояния всех блоков не повторятся (то есть пока не случится предельный цикл или стационарная точка).

Это был "классический" случай. Могут быть и иные варианты работы, однако суть, я думаю, ясна: механизм обрабаывая данные, меняется. Однако меняться он может, например, не детерминированно, а стохастически, и функции (методы, если хотите) для этого уже реализованы. В стохастическом случае коррекция может производиться либо с определённым шансом, либо на определённую величину, зависящую либо от состояния всей системы, либо от состояния изменяющего блока (либо от его выхода). Так реализуется "самоизменение" и "самоопределение" системы в рамках, допускаемых тьюринговской вычислимостью, что приближает нас к имитации (M,R) систем. 

## Практическое применение
Его нет (по крайней мере, пока что). Я серьёзно. Для производства, бизнеса и прочего это абсолютно бесполезная штука (на момент 10 октября 2025 года). Проект представляет собой ценность скорее эстетическую и научно-исследовательскую (по крайней мере для автора и научно-учебной группы).

## Перспективы
На данный момент я планирую использовать представленный логический механизм в качестве элемента/нейрона в нейронных сетях и тому подобном. Существуют же самоорганизующиеся карты Кохонена из элементов на освное радиально-базисных функций? Почему не может быть чего-то подобного (или вообще иного?) на основе (M,R) механизмов?

## Проблемы проекта
Несмотря на полное переписывание вручную в ООП-стиль из процедурного vibe-code-style, а также потом разбивку огромного файла на компоненты/файлы, у проекта всё же есть большой недостаток - отсутствие хоть какой-нибудь документации (что, кстати, связано с неразработанностью теории логик, на которой он, в частности, основан). В остальном же, я считаю, по коду всё гораздо лучше, чем было год назад. Да даже полгода назад это было ужасно.

## Как запустить
Просто скачайте репозиторий и в директории, где лежит main.cpp, запустите следующую команду:
```
g++ -O3 -static -static-libgcc -static-libstdc++ -Iinclude src/henkamono.cpp src/utils.cpp src/random_utils.cpp src/block.cpp main.cpp -o main.exe
```

Если у вас другой компилятор, то просто чуть-чуть поменяйте под свои нужды. Также учтите, что здесь я использую самый высокий уровень оптимизации, так что не могу гарантировать, что на вашем железе проект соберётся быстро, однако я точно могу гарантировать, что код будет выполнять в 20 раз быстрее, чем выполнялся бы без этой оптимизации (по крайней мере в одном тестовом случае это было так).

## Что дальше
После запуска программа напечатает вам числа. Эти числа - те числа, которые не получились из двоичного представления, получаемого конкатенацией всех состояний блоков логического механизма на каждом шаге его работы.

Вы, разумеется, можете там всё перенастроить под себя и так далее, только, пожалуйста, не забудьте в итоге, если будете где-то, публиковать свои наработки, упомянуть автора и дать ссылку на этот репозиторий - вам несложно, а мне приятно.

Надеюсь, что вы найдёте этому коду достойное применение (только не делайте из него оружие и какое-либо средство ведения агрессивной войны).
